#!/usr/bin/env python3
import hashlib
import re
import shutil
from pathlib import Path

PROJECT_ROOT = Path(".").resolve()
DOS_ROOT     = PROJECT_ROOT / "DOS"
STAGE_NAME   = ""                 # подкаталог внутри DOS/ ("" => прямо DOS/)
STAGE_DIR    = DOS_ROOT / STAGE_NAME

EXE_NAME     = "OPENPOLE.EXE"
STACK_SIZE   = 2048
CFLAGS_EXTRA = "-d0 -onatx -zp4 -dRELEASE -dDOSBUILD"
MANIFEST     = "DOSIFY.MAN"

DOS_BASE_MAX = 8
DOS_EXT_MAX  = 3

_include_re = re.compile(r'^\s*#\s*include\s*([<"])([^">]+)([>"])\s*(.*)$')


def norm_inc(p: str) -> str:
    p = p.strip().replace("\\", "/")
    while p.startswith("./"):
        p = p[2:]
    return p


def inc_keys(p: str):
    pn = norm_inc(p)
    base = pn.split("/")[-1]
    return pn.lower(), base.lower()


def sanitize_base(s: str) -> str:
    s = re.sub(r"[^A-Z0-9_]", "", s.upper())
    return s or "FILE"


def dos83_name(stem: str, ext: str, used: dict) -> str:
    ext = ext.upper().lstrip(".")[:DOS_EXT_MAX]
    base = sanitize_base(stem)

    base0 = base[:DOS_BASE_MAX]
    cand = f"{base0}.{ext}" if ext else base0
    if cand not in used:
        used[cand] = 1
        return cand

    for n in range(1, 1000):
        suffix = f"~{n}"
        keep = DOS_BASE_MAX - len(suffix)
        if keep < 1:
            continue
        b = base[:keep] + suffix
        cand = f"{b}.{ext}" if ext else b
        if cand not in used:
            used[cand] = 1
            return cand

    h = hashlib.sha1((stem + "." + ext).encode("utf-8", "ignore")).hexdigest().upper()
    b = h[:DOS_BASE_MAX]
    cand = f"{b}.{ext}" if ext else b
    if cand not in used:
        used[cand] = 1
        return cand

    k = used.get(cand, 1)
    used[cand] = k + 1
    b2 = b[:DOS_BASE_MAX - 1] + str(k % 10)
    return f"{b2}.{ext}" if ext else b2


def decode_best(data: bytes):
    for enc in ("cp866", "cp1251", "latin-1", "utf-8"):
        try:
            return data.decode(enc), enc
        except Exception:
            pass
    raise UnicodeDecodeError("unknown", b"", 0, 1, "cannot decode")


def read_manifest(stage: Path):
    p = stage / MANIFEST
    if not p.exists():
        return []
    out = []
    for ln in p.read_text(encoding="utf-8", errors="ignore").splitlines():
        ln = ln.strip()
        if ln and not ln.startswith("#"):
            out.append(ln)
    return out


def write_manifest(stage: Path, relpaths):
    p = stage / MANIFEST
    text = ["# generated by dosify.py (safe to delete)", *relpaths, ""]
    p.write_text("\n".join(text), encoding="utf-8", newline="\n")


def cleanup_by_manifest(stage: Path):
    for rel in read_manifest(stage):
        p = stage / rel
        try:
            if p.is_dir():
                shutil.rmtree(p)
            elif p.exists():
                p.unlink()
        except Exception:
            pass

    for pat in ("*.OBJ", "*.EXE", "*.MAP", "LINK.LNK"):
        for p in stage.glob(pat):
            try:
                p.unlink()
            except Exception:
                pass


def collect_inputs(root: Path):
    polec = root / "openpole.c"
    if not polec.is_file():
        raise FileNotFoundError("missing required file: ./openpole.c")

    files = [polec]

    src = root / "src"
    inc = root / "inc"

    if src.is_dir():
        files += sorted([p for p in src.rglob("*.c") if p.is_file()])
    if inc.is_dir():
        files += sorted([p for p in inc.rglob("*.h") if p.is_file()])

    return files


def rewrite_includes(path: Path, inc_map: dict, log: list):
    text, enc = decode_best(path.read_bytes())

    out_lines = []
    changed = 0

    for line in text.splitlines(keepends=True):
        m = _include_re.match(line)
        if not m:
            out_lines.append(line)
            continue

        od, incp, cd = m.group(1), m.group(2), m.group(3)
        k_full, k_base = inc_keys(incp)
        new_name = inc_map.get(k_full) or inc_map.get(k_base)

        if not new_name:
            out_lines.append(line)
            continue

        new_line = re.sub(
            r'^\s*#\s*include\s*[<"][^">]+[>"]',
            f'#include {od}{new_name}{cd}',
            line
        )
        out_lines.append(new_line)
        if new_line != line:
            changed += 1

    if changed:
        path.write_text("".join(out_lines), encoding=enc, newline="")
        log.append(f"{path.name}: rewrote {changed} include(s)")


def generate_makefile(stage: Path):
    c_files = sorted([p.name.upper() for p in stage.iterdir()
                      if p.is_file() and p.suffix.lower() == ".c"])
    obj_files = [Path(n).with_suffix(".OBJ").name for n in c_files]
    objs_line = " ".join(obj_files)

    cflags = f"-0 -mm -bt=dos {CFLAGS_EXTRA}".strip()

    link = [
        "LINK.LNK : .symbolic",
        "  @%write  $@ system dos",
        "  @%append $@ option map",
        "  @%append $@ option eliminate",
        "  @%append $@ option stack=$(STACK)",
        "  @%append $@ name $(EXE)",
    ]
    for i in range(0, len(obj_files), 2):
        a = obj_files[i]
        b = obj_files[i + 1] if i + 1 < len(obj_files) else None
        link.append(f"  @%append $@ file {a}" + (f" file {b}" if b else ""))

    mf = [
        "# Auto-generated by dosify.py",
        "",
        f"EXE   = {EXE_NAME}",
        f"STACK = {STACK_SIZE}",
        f"CFLAGS = {cflags}",
        "",
        f"OBJS = {objs_line}",
        "",
        "all : $(EXE)",
        "",
        "clean : .symbolic",
        "  @if exist *.obj del *.obj",
        "  @if exist *.exe del *.exe",
        "  @if exist *.map del *.map",
        "  @if exist LINK.LNK del LINK.LNK",
        "",
        ".c.obj :",
        "  wcc $(CFLAGS) $[*.c",
        "",
        *link,
        "",
        "$(EXE) : $(OBJS) LINK.LNK",
        "  wlink @LINK.LNK",
        "",
    ]
    (stage / "MAKEFILE").write_text("\n".join(mf) + "\n",
                                    encoding="ascii", errors="ignore", newline="\r\n")


def main() -> int:
    DOS_ROOT.mkdir(parents=True, exist_ok=True)
    STAGE_DIR.mkdir(parents=True, exist_ok=True)

    cleanup_by_manifest(STAGE_DIR)

    inputs = collect_inputs(PROJECT_ROOT)

    used = {}
    infos = []
    for p in inputs:
        name = dos83_name(p.stem, p.suffix, used)
        infos.append((p, name, STAGE_DIR / name))  # (src, dst_name, dst_path)

    inc_map = {}
    for src, dst_name, _dst in infos:
        inc_map[src.name.lower()] = dst_name
        rel = src.relative_to(PROJECT_ROOT).as_posix()
        inc_map[norm_inc(rel).lower()] = dst_name

    for src, _dst_name, dst in infos:
        shutil.copy2(src, dst)

    log = []
    for _src, _dst_name, dst in infos:
        if dst.suffix.lower() in (".c", ".h"):
            rewrite_includes(dst, inc_map, log)

    generate_makefile(STAGE_DIR)

    (STAGE_DIR / "README_DOSIFY.TXT").write_text(
        "\r\n".join([
            "DOS BUILD (Open Watcom)",
            "",
            f"Stage dir: {STAGE_NAME}",
            "Run in DOS:",
            "  cd \\DOS\\",
            "  make.bat",
            "",
            "Link: wlink @LINK.LNK",
            "",
        ]) + "\r\n",
        encoding="ascii", errors="ignore", newline="\r\n"
    )

    rels = [dst.name for _src, _dst_name, dst in infos] + ["MAKEFILE", "README_DOSIFY.TXT", MANIFEST]
    write_manifest(STAGE_DIR, sorted(set(rels), key=lambda s: s.upper()))

    (STAGE_DIR / "DOSIFY_MAP.TXT").write_text(
        "\n".join([
            "RENAMED:",
            *[f"{src.relative_to(PROJECT_ROOT).as_posix()} -> {dst_name}" for (src, dst_name, _dst) in infos],
            "",
            "INCLUDE REWRITES:",
            *(log if log else ["(none)"]),
            "",
        ]),
        encoding="utf-8", newline="\n"
    )

    print(f"[OK] DOS root untouched: {DOS_ROOT}")
    print(f"[OK] Project staged into: {STAGE_DIR}")
    print(f"[OK] Build: {STAGE_DIR / 'MAKEFILE'}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())